{"version":3,"file":"static/js/953.21e33e1b.chunk.js","mappings":"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","sources":["../node_modules/@graphiql/graphql-language-service/esm/utils/Range.js","../node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs","../node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs","../node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs","../node_modules/graphql/language/predicates.mjs","../node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs","../node_modules/graphql/validation/rules/KnownDirectivesRule.mjs","../node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs","../node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs","../node_modules/graphql/jsutils/groupBy.mjs","../node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs","../node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs","../node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs","../node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs","../node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs","../node_modules/graphql/utilities/sortValueNode.mjs","../node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs","../node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs","../node_modules/graphql/execution/values.mjs","../node_modules/graphql/execution/collectFields.mjs","../node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs","../node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs","../node_modules/graphql/validation/specifiedRules.mjs","../node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs","../node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs","../node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs","../node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs","../node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs","../node_modules/graphql/validation/rules/ScalarLeafsRule.mjs","../node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs","../node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs","../node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs","../node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs","../node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs","../node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs","../node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs","../node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs","../node_modules/graphql/validation/ValidationContext.mjs","../node_modules/graphql/validation/validate.mjs","../node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs","../node_modules/@graphiql/graphql-language-service/esm/utils/validateWithCustomRules.js","../node_modules/@graphiql/graphql-language-service/esm/interface/getDiagnostics.js","../node_modules/@graphiql/codemirror-graphql/esm/lint.js"],"sourcesContent":["export class Range {\n    constructor(start, end) {\n        this.containsPosition = (position) => {\n            if (this.start.line === position.line) {\n                return this.start.character <= position.character;\n            }\n            if (this.end.line === position.line) {\n                return this.end.character >= position.character;\n            }\n            return this.start.line <= position.line && this.end.line >= position.line;\n        };\n        this.start = start;\n        this.end = end;\n    }\n    setStart(line, character) {\n        this.start = new Position(line, character);\n    }\n    setEnd(line, character) {\n        this.end = new Position(line, character);\n    }\n}\nexport class Position {\n    constructor(line, character) {\n        this.lessThanOrEqualTo = (position) => this.line < position.line ||\n            (this.line === position.line && this.character <= position.character);\n        this.line = line;\n        this.character = character;\n    }\n    setLine(line) {\n        this.line = line;\n    }\n    setCharacter(character) {\n        this.character = character;\n    }\n}\nexport function offsetToPosition(text, loc) {\n    const EOL = '\\n';\n    const buf = text.slice(0, loc);\n    const lines = buf.split(EOL).length - 1;\n    const lastLineIndex = buf.lastIndexOf(EOL);\n    return new Position(lines, loc - lastLineIndex - 1);\n}\nexport function locToRange(text, loc) {\n    const start = offsetToPosition(text, loc.start);\n    const end = offsetToPosition(text, loc.end);\n    return new Range(start, end);\n}\n//# sourceMappingURL=Range.js.map","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Lone Schema definition\n *\n * A GraphQL document is only valid if it contains only one schema definition.\n */\nexport function LoneSchemaDefinitionRule(context) {\n  var _ref, _ref2, _oldSchema$astNode;\n\n  const oldSchema = context.getSchema();\n  const alreadyDefined =\n    (_ref =\n      (_ref2 =\n        (_oldSchema$astNode =\n          oldSchema === null || oldSchema === void 0\n            ? void 0\n            : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0\n          ? _oldSchema$astNode\n          : oldSchema === null || oldSchema === void 0\n          ? void 0\n          : oldSchema.getQueryType()) !== null && _ref2 !== void 0\n        ? _ref2\n        : oldSchema === null || oldSchema === void 0\n        ? void 0\n        : oldSchema.getMutationType()) !== null && _ref !== void 0\n      ? _ref\n      : oldSchema === null || oldSchema === void 0\n      ? void 0\n      : oldSchema.getSubscriptionType();\n  let schemaDefinitionsCount = 0;\n  return {\n    SchemaDefinition(node) {\n      if (alreadyDefined) {\n        context.reportError(\n          new GraphQLError(\n            'Cannot define a new schema within a schema extension.',\n            {\n              nodes: node,\n            },\n          ),\n        );\n        return;\n      }\n\n      if (schemaDefinitionsCount > 0) {\n        context.reportError(\n          new GraphQLError('Must provide only one schema definition.', {\n            nodes: node,\n          }),\n        );\n      }\n\n      ++schemaDefinitionsCount;\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique operation types\n *\n * A GraphQL document is only valid if it has only one type per operation.\n */\nexport function UniqueOperationTypesRule(context) {\n  const schema = context.getSchema();\n  const definedOperationTypes = Object.create(null);\n  const existingOperationTypes = schema\n    ? {\n        query: schema.getQueryType(),\n        mutation: schema.getMutationType(),\n        subscription: schema.getSubscriptionType(),\n      }\n    : {};\n  return {\n    SchemaDefinition: checkOperationTypes,\n    SchemaExtension: checkOperationTypes,\n  };\n\n  function checkOperationTypes(node) {\n    var _node$operationTypes;\n\n    // See: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n    const operationTypesNodes =\n      (_node$operationTypes = node.operationTypes) !== null &&\n      _node$operationTypes !== void 0\n        ? _node$operationTypes\n        : [];\n\n    for (const operationType of operationTypesNodes) {\n      const operation = operationType.operation;\n      const alreadyDefinedOperationType = definedOperationTypes[operation];\n\n      if (existingOperationTypes[operation]) {\n        context.reportError(\n          new GraphQLError(\n            `Type for ${operation} already defined in the schema. It cannot be redefined.`,\n            {\n              nodes: operationType,\n            },\n          ),\n        );\n      } else if (alreadyDefinedOperationType) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one ${operation} type in schema.`,\n            {\n              nodes: [alreadyDefinedOperationType, operationType],\n            },\n          ),\n        );\n      } else {\n        definedOperationTypes[operation] = operationType;\n      }\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique type names\n *\n * A GraphQL document is only valid if all defined types have unique names.\n */\nexport function UniqueTypeNamesRule(context) {\n  const knownTypeNames = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    ScalarTypeDefinition: checkTypeName,\n    ObjectTypeDefinition: checkTypeName,\n    InterfaceTypeDefinition: checkTypeName,\n    UnionTypeDefinition: checkTypeName,\n    EnumTypeDefinition: checkTypeName,\n    InputObjectTypeDefinition: checkTypeName,\n  };\n\n  function checkTypeName(node) {\n    const typeName = node.name.value;\n\n    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {\n      context.reportError(\n        new GraphQLError(\n          `Type \"${typeName}\" already exists in the schema. It cannot also be defined in this type definition.`,\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n      return;\n    }\n\n    if (knownTypeNames[typeName]) {\n      context.reportError(\n        new GraphQLError(`There can be only one type named \"${typeName}\".`, {\n          nodes: [knownTypeNames[typeName], node.name],\n        }),\n      );\n    } else {\n      knownTypeNames[typeName] = node.name;\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { isEnumType } from '../../type/definition.mjs';\n\n/**\n * Unique enum value names\n *\n * A GraphQL enum type is only valid if all its values are uniquely named.\n */\nexport function UniqueEnumValueNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownValueNames = Object.create(null);\n  return {\n    EnumTypeDefinition: checkValueUniqueness,\n    EnumTypeExtension: checkValueUniqueness,\n  };\n\n  function checkValueUniqueness(node) {\n    var _node$values;\n\n    const typeName = node.name.value;\n\n    if (!knownValueNames[typeName]) {\n      knownValueNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const valueNodes =\n      (_node$values = node.values) !== null && _node$values !== void 0\n        ? _node$values\n        : [];\n    const valueNames = knownValueNames[typeName];\n\n    for (const valueDef of valueNodes) {\n      const valueName = valueDef.name.value;\n      const existingType = existingTypeMap[typeName];\n\n      if (isEnumType(existingType) && existingType.getValue(valueName)) {\n        context.reportError(\n          new GraphQLError(\n            `Enum value \"${typeName}.${valueName}\" already exists in the schema. It cannot also be defined in this type extension.`,\n            {\n              nodes: valueDef.name,\n            },\n          ),\n        );\n      } else if (valueNames[valueName]) {\n        context.reportError(\n          new GraphQLError(\n            `Enum value \"${typeName}.${valueName}\" can only be defined once.`,\n            {\n              nodes: [valueNames[valueName], valueDef.name],\n            },\n          ),\n        );\n      } else {\n        valueNames[valueName] = valueDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n} from '../../type/definition.mjs';\n\n/**\n * Unique field definition names\n *\n * A GraphQL complex type is only valid if all its fields are uniquely named.\n */\nexport function UniqueFieldDefinitionNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownFieldNames = Object.create(null);\n  return {\n    InputObjectTypeDefinition: checkFieldUniqueness,\n    InputObjectTypeExtension: checkFieldUniqueness,\n    InterfaceTypeDefinition: checkFieldUniqueness,\n    InterfaceTypeExtension: checkFieldUniqueness,\n    ObjectTypeDefinition: checkFieldUniqueness,\n    ObjectTypeExtension: checkFieldUniqueness,\n  };\n\n  function checkFieldUniqueness(node) {\n    var _node$fields;\n\n    const typeName = node.name.value;\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const fieldNodes =\n      (_node$fields = node.fields) !== null && _node$fields !== void 0\n        ? _node$fields\n        : [];\n    const fieldNames = knownFieldNames[typeName];\n\n    for (const fieldDef of fieldNodes) {\n      const fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        context.reportError(\n          new GraphQLError(\n            `Field \"${typeName}.${fieldName}\" already exists in the schema. It cannot also be defined in this type extension.`,\n            {\n              nodes: fieldDef.name,\n            },\n          ),\n        );\n      } else if (fieldNames[fieldName]) {\n        context.reportError(\n          new GraphQLError(\n            `Field \"${typeName}.${fieldName}\" can only be defined once.`,\n            {\n              nodes: [fieldNames[fieldName], fieldDef.name],\n            },\n          ),\n        );\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n\nfunction hasField(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n    return type.getFields()[fieldName] != null;\n  }\n\n  return false;\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique directive names\n *\n * A GraphQL document is only valid if all defined directives have unique names.\n */\nexport function UniqueDirectiveNamesRule(context) {\n  const knownDirectiveNames = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    DirectiveDefinition(node) {\n      const directiveName = node.name.value;\n\n      if (\n        schema !== null &&\n        schema !== void 0 &&\n        schema.getDirective(directiveName)\n      ) {\n        context.reportError(\n          new GraphQLError(\n            `Directive \"@${directiveName}\" already exists in the schema. It cannot be redefined.`,\n            {\n              nodes: node.name,\n            },\n          ),\n        );\n        return;\n      }\n\n      if (knownDirectiveNames[directiveName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one directive named \"@${directiveName}\".`,\n            {\n              nodes: [knownDirectiveNames[directiveName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownDirectiveNames[directiveName] = node.name;\n      }\n\n      return false;\n    },\n  };\n}\n","import { Kind } from './kinds.mjs';\nexport function isDefinitionNode(node) {\n  return (\n    isExecutableDefinitionNode(node) ||\n    isTypeSystemDefinitionNode(node) ||\n    isTypeSystemExtensionNode(node)\n  );\n}\nexport function isExecutableDefinitionNode(node) {\n  return (\n    node.kind === Kind.OPERATION_DEFINITION ||\n    node.kind === Kind.FRAGMENT_DEFINITION\n  );\n}\nexport function isSelectionNode(node) {\n  return (\n    node.kind === Kind.FIELD ||\n    node.kind === Kind.FRAGMENT_SPREAD ||\n    node.kind === Kind.INLINE_FRAGMENT\n  );\n}\nexport function isValueNode(node) {\n  return (\n    node.kind === Kind.VARIABLE ||\n    node.kind === Kind.INT ||\n    node.kind === Kind.FLOAT ||\n    node.kind === Kind.STRING ||\n    node.kind === Kind.BOOLEAN ||\n    node.kind === Kind.NULL ||\n    node.kind === Kind.ENUM ||\n    node.kind === Kind.LIST ||\n    node.kind === Kind.OBJECT\n  );\n}\nexport function isConstValueNode(node) {\n  return (\n    isValueNode(node) &&\n    (node.kind === Kind.LIST\n      ? node.values.some(isConstValueNode)\n      : node.kind === Kind.OBJECT\n      ? node.fields.some((field) => isConstValueNode(field.value))\n      : node.kind !== Kind.VARIABLE)\n  );\n}\nexport function isTypeNode(node) {\n  return (\n    node.kind === Kind.NAMED_TYPE ||\n    node.kind === Kind.LIST_TYPE ||\n    node.kind === Kind.NON_NULL_TYPE\n  );\n}\nexport function isTypeSystemDefinitionNode(node) {\n  return (\n    node.kind === Kind.SCHEMA_DEFINITION ||\n    isTypeDefinitionNode(node) ||\n    node.kind === Kind.DIRECTIVE_DEFINITION\n  );\n}\nexport function isTypeDefinitionNode(node) {\n  return (\n    node.kind === Kind.SCALAR_TYPE_DEFINITION ||\n    node.kind === Kind.OBJECT_TYPE_DEFINITION ||\n    node.kind === Kind.INTERFACE_TYPE_DEFINITION ||\n    node.kind === Kind.UNION_TYPE_DEFINITION ||\n    node.kind === Kind.ENUM_TYPE_DEFINITION ||\n    node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION\n  );\n}\nexport function isTypeSystemExtensionNode(node) {\n  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);\n}\nexport function isTypeExtensionNode(node) {\n  return (\n    node.kind === Kind.SCALAR_TYPE_EXTENSION ||\n    node.kind === Kind.OBJECT_TYPE_EXTENSION ||\n    node.kind === Kind.INTERFACE_TYPE_EXTENSION ||\n    node.kind === Kind.UNION_TYPE_EXTENSION ||\n    node.kind === Kind.ENUM_TYPE_EXTENSION ||\n    node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION\n  );\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeSystemDefinitionNode,\n  isTypeSystemExtensionNode,\n} from '../../language/predicates.mjs';\nimport { introspectionTypes } from '../../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../../type/scalars.mjs';\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Spread-Type-Existence\n */\nexport function KnownTypeNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  const typeNames = [\n    ...Object.keys(existingTypesMap),\n    ...Object.keys(definedTypes),\n  ];\n  return {\n    NamedType(node, _1, parent, _2, ancestors) {\n      const typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        const definitionNode =\n          (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0\n            ? _ancestors$\n            : parent;\n        const isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && standardTypeNames.includes(typeName)) {\n          return;\n        }\n\n        const suggestedTypes = suggestionList(\n          typeName,\n          isSDL ? standardTypeNames.concat(typeNames) : typeNames,\n        );\n        context.reportError(\n          new GraphQLError(\n            `Unknown type \"${typeName}\".` + didYouMean(suggestedTypes),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\nconst standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(\n  (type) => type.name,\n);\n\nfunction isSDLNode(value) {\n  return (\n    'kind' in value &&\n    (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value))\n  );\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../../language/ast.mjs';\nimport { DirectiveLocation } from '../../language/directiveLocation.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Known directives\n *\n * A GraphQL document is only valid if all `@directives` are known by the\n * schema and legally positioned.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Defined\n */\nexport function KnownDirectivesRule(context) {\n  const locationsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    locationsMap[directive.name] = directive.locations;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      locationsMap[def.name.value] = def.locations.map((name) => name.value);\n    }\n  }\n\n  return {\n    Directive(node, _key, _parent, _path, ancestors) {\n      const name = node.name.value;\n      const locations = locationsMap[name];\n\n      if (!locations) {\n        context.reportError(\n          new GraphQLError(`Unknown directive \"@${name}\".`, {\n            nodes: node,\n          }),\n        );\n        return;\n      }\n\n      const candidateLocation = getDirectiveLocationForASTPath(ancestors);\n\n      if (candidateLocation && !locations.includes(candidateLocation)) {\n        context.reportError(\n          new GraphQLError(\n            `Directive \"@${name}\" may not be used on ${candidateLocation}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getDirectiveLocationForASTPath(ancestors) {\n  const appliedTo = ancestors[ancestors.length - 1];\n  'kind' in appliedTo || invariant(false);\n\n  switch (appliedTo.kind) {\n    case Kind.OPERATION_DEFINITION:\n      return getDirectiveLocationForOperation(appliedTo.operation);\n\n    case Kind.FIELD:\n      return DirectiveLocation.FIELD;\n\n    case Kind.FRAGMENT_SPREAD:\n      return DirectiveLocation.FRAGMENT_SPREAD;\n\n    case Kind.INLINE_FRAGMENT:\n      return DirectiveLocation.INLINE_FRAGMENT;\n\n    case Kind.FRAGMENT_DEFINITION:\n      return DirectiveLocation.FRAGMENT_DEFINITION;\n\n    case Kind.VARIABLE_DEFINITION:\n      return DirectiveLocation.VARIABLE_DEFINITION;\n\n    case Kind.SCHEMA_DEFINITION:\n    case Kind.SCHEMA_EXTENSION:\n      return DirectiveLocation.SCHEMA;\n\n    case Kind.SCALAR_TYPE_DEFINITION:\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return DirectiveLocation.SCALAR;\n\n    case Kind.OBJECT_TYPE_DEFINITION:\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.OBJECT;\n\n    case Kind.FIELD_DEFINITION:\n      return DirectiveLocation.FIELD_DEFINITION;\n\n    case Kind.INTERFACE_TYPE_DEFINITION:\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return DirectiveLocation.INTERFACE;\n\n    case Kind.UNION_TYPE_DEFINITION:\n    case Kind.UNION_TYPE_EXTENSION:\n      return DirectiveLocation.UNION;\n\n    case Kind.ENUM_TYPE_DEFINITION:\n    case Kind.ENUM_TYPE_EXTENSION:\n      return DirectiveLocation.ENUM;\n\n    case Kind.ENUM_VALUE_DEFINITION:\n      return DirectiveLocation.ENUM_VALUE;\n\n    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.INPUT_OBJECT;\n\n    case Kind.INPUT_VALUE_DEFINITION: {\n      const parentNode = ancestors[ancestors.length - 3];\n      'kind' in parentNode || invariant(false);\n      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION\n        ? DirectiveLocation.INPUT_FIELD_DEFINITION\n        : DirectiveLocation.ARGUMENT_DEFINITION;\n    }\n    // Not reachable, all possible types have been considered.\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(appliedTo.kind));\n  }\n}\n\nfunction getDirectiveLocationForOperation(operation) {\n  switch (operation) {\n    case OperationTypeNode.QUERY:\n      return DirectiveLocation.QUERY;\n\n    case OperationTypeNode.MUTATION:\n      return DirectiveLocation.MUTATION;\n\n    case OperationTypeNode.SUBSCRIPTION:\n      return DirectiveLocation.SUBSCRIPTION;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeExtensionNode,\n} from '../../language/predicates.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Unique-Per-Location\n */\nexport function UniqueDirectivesPerLocationRule(context) {\n  const uniqueDirectiveMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  const schemaDirectives = Object.create(null);\n  const typeDirectivesMap = Object.create(null);\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter(node) {\n      if (!('directives' in node) || !node.directives) {\n        return;\n      }\n\n      let seenDirectives;\n\n      if (\n        node.kind === Kind.SCHEMA_DEFINITION ||\n        node.kind === Kind.SCHEMA_EXTENSION\n      ) {\n        seenDirectives = schemaDirectives;\n      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {\n        const typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n\n        if (seenDirectives === undefined) {\n          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);\n        }\n      } else {\n        seenDirectives = Object.create(null);\n      }\n\n      for (const directive of node.directives) {\n        const directiveName = directive.name.value;\n\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(\n              new GraphQLError(\n                `The directive \"@${directiveName}\" can only be used once at this location.`,\n                {\n                  nodes: [seenDirectives[directiveName], directive],\n                },\n              ),\n            );\n          } else {\n            seenDirectives[directiveName] = directive;\n          }\n        }\n      }\n    },\n  };\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isTypeDefinitionNode } from '../../language/predicates.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../../type/definition.mjs';\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nexport function PossibleTypeExtensionsRule(context) {\n  const schema = context.getSchema();\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension,\n  };\n\n  function checkExtension(node) {\n    const typeName = node.name.value;\n    const defNode = definedTypes[typeName];\n    const existingType =\n      schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    let expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        const kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(\n          new GraphQLError(`Cannot extend non-${kindStr} type \"${typeName}\".`, {\n            nodes: defNode ? [defNode, node] : node,\n          }),\n        );\n      }\n    } else {\n      const allTypeNames = Object.keys({\n        ...definedTypes,\n        ...(schema === null || schema === void 0\n          ? void 0\n          : schema.getTypeMap()),\n      });\n      const suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(\n        new GraphQLError(\n          `Cannot extend type \"${typeName}\" because it is not defined.` +\n            didYouMean(suggestedTypes),\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n    }\n  }\n}\nconst defKindToExtKind = {\n  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,\n  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,\n  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,\n  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,\n  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,\n  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n};\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  }\n\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable. All possible types have been considered\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n    // Not reachable. All possible types have been considered\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(kind));\n  }\n}\n","/**\n * Groups array items into a Map, given a function to produce grouping key.\n */\nexport function groupBy(list, keyFn) {\n  const result = new Map();\n\n  for (const item of list) {\n    const key = keyFn(item);\n    const group = result.get(key);\n\n    if (group === undefined) {\n      result.set(key, [item]);\n    } else {\n      group.push(item);\n    }\n  }\n\n  return result;\n}\n","import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique argument names\n *\n * A GraphQL field or directive is only valid if all supplied arguments are\n * uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Argument-Names\n */\nexport function UniqueArgumentNamesRule(context) {\n  return {\n    Field: checkArgUniqueness,\n    Directive: checkArgUniqueness,\n  };\n\n  function checkArgUniqueness(parentNode) {\n    var _parentNode$arguments;\n\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n    const argumentNodes =\n      (_parentNode$arguments = parentNode.arguments) !== null &&\n      _parentNode$arguments !== void 0\n        ? _parentNode$arguments\n        : [];\n    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);\n\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one argument named \"${argName}\".`,\n            {\n              nodes: argNodes.map((node) => node.name),\n            },\n          ),\n        );\n      }\n    }\n  }\n}\n","import { invariant } from '../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique input field names\n *\n * A GraphQL input object value is only valid if all supplied fields are\n * uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Input-Object-Field-Uniqueness\n */\nexport function UniqueInputFieldNamesRule(context) {\n  const knownNameStack = [];\n  let knownNames = Object.create(null);\n  return {\n    ObjectValue: {\n      enter() {\n        knownNameStack.push(knownNames);\n        knownNames = Object.create(null);\n      },\n\n      leave() {\n        const prevKnownNames = knownNameStack.pop();\n        prevKnownNames || invariant(false);\n        knownNames = prevKnownNames;\n      },\n    },\n\n    ObjectField(node) {\n      const fieldName = node.name.value;\n\n      if (knownNames[fieldName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one input field named \"${fieldName}\".`,\n            {\n              nodes: [knownNames[fieldName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownNames[fieldName] = node.name;\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isExecutableDefinitionNode } from '../../language/predicates.mjs';\n\n/**\n * Executable definitions\n *\n * A GraphQL document is only valid for execution if all definitions are either\n * operation or fragment definitions.\n *\n * See https://spec.graphql.org/draft/#sec-Executable-Definitions\n */\nexport function ExecutableDefinitionsRule(context) {\n  return {\n    Document(node) {\n      for (const definition of node.definitions) {\n        if (!isExecutableDefinitionNode(definition)) {\n          const defName =\n            definition.kind === Kind.SCHEMA_DEFINITION ||\n            definition.kind === Kind.SCHEMA_EXTENSION\n              ? 'schema'\n              : '\"' + definition.name.value + '\"';\n          context.reportError(\n            new GraphQLError(`The ${defName} definition is not executable.`, {\n              nodes: definition,\n            }),\n          );\n        }\n      }\n\n      return false;\n    },\n  };\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Known argument names\n *\n * A GraphQL field is only valid if all supplied arguments are defined by\n * that field.\n *\n * See https://spec.graphql.org/draft/#sec-Argument-Names\n * See https://spec.graphql.org/draft/#sec-Directives-Are-In-Valid-Locations\n */\nexport function KnownArgumentNamesRule(context) {\n  return {\n    // eslint-disable-next-line new-cap\n    ...KnownArgumentNamesOnDirectivesRule(context),\n\n    Argument(argNode) {\n      const argDef = context.getArgument();\n      const fieldDef = context.getFieldDef();\n      const parentType = context.getParentType();\n\n      if (!argDef && fieldDef && parentType) {\n        const argName = argNode.name.value;\n        const knownArgsNames = fieldDef.args.map((arg) => arg.name);\n        const suggestions = suggestionList(argName, knownArgsNames);\n        context.reportError(\n          new GraphQLError(\n            `Unknown argument \"${argName}\" on field \"${parentType.name}.${fieldDef.name}\".` +\n              didYouMean(suggestions),\n            {\n              nodes: argNode,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n/**\n * @internal\n */\n\nexport function KnownArgumentNamesOnDirectivesRule(context) {\n  const directiveArgs = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argsNodes =\n        (_def$arguments = def.arguments) !== null && _def$arguments !== void 0\n          ? _def$arguments\n          : [];\n      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);\n    }\n  }\n\n  return {\n    Directive(directiveNode) {\n      const directiveName = directiveNode.name.value;\n      const knownArgs = directiveArgs[directiveName];\n\n      if (directiveNode.arguments && knownArgs) {\n        for (const argNode of directiveNode.arguments) {\n          const argName = argNode.name.value;\n\n          if (!knownArgs.includes(argName)) {\n            const suggestions = suggestionList(argName, knownArgs);\n            context.reportError(\n              new GraphQLError(\n                `Unknown argument \"${argName}\" on directive \"@${directiveName}\".` +\n                  didYouMean(suggestions),\n                {\n                  nodes: argNode,\n                },\n              ),\n            );\n          }\n        }\n      }\n\n      return false;\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Known fragment names\n *\n * A GraphQL document is only valid if all `...Fragment` fragment spreads refer\n * to fragments defined in the same document.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spread-target-defined\n */\nexport function KnownFragmentNamesRule(context) {\n  return {\n    FragmentSpread(node) {\n      const fragmentName = node.name.value;\n      const fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        context.reportError(\n          new GraphQLError(`Unknown fragment \"${fragmentName}\".`, {\n            nodes: node.name,\n          }),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No unused fragments\n *\n * A GraphQL document is only valid if all fragment definitions are spread\n * within operations, or spread within other fragments spread within operations.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-Must-Be-Used\n */\nexport function NoUnusedFragmentsRule(context) {\n  const operationDefs = [];\n  const fragmentDefs = [];\n  return {\n    OperationDefinition(node) {\n      operationDefs.push(node);\n      return false;\n    },\n\n    FragmentDefinition(node) {\n      fragmentDefs.push(node);\n      return false;\n    },\n\n    Document: {\n      leave() {\n        const fragmentNameUsed = Object.create(null);\n\n        for (const operation of operationDefs) {\n          for (const fragment of context.getRecursivelyReferencedFragments(\n            operation,\n          )) {\n            fragmentNameUsed[fragment.name.value] = true;\n          }\n        }\n\n        for (const fragmentDef of fragmentDefs) {\n          const fragName = fragmentDef.name.value;\n\n          if (fragmentNameUsed[fragName] !== true) {\n            context.reportError(\n              new GraphQLError(`Fragment \"${fragName}\" is never used.`, {\n                nodes: fragmentDef,\n              }),\n            );\n          }\n        }\n      },\n    },\n  };\n}\n","import { naturalCompare } from '../jsutils/naturalCompare.mjs';\nimport { Kind } from '../language/kinds.mjs';\n/**\n * Sort ValueNode.\n *\n * This function returns a sorted copy of the given ValueNode.\n *\n * @internal\n */\n\nexport function sortValueNode(valueNode) {\n  switch (valueNode.kind) {\n    case Kind.OBJECT:\n      return { ...valueNode, fields: sortFields(valueNode.fields) };\n\n    case Kind.LIST:\n      return { ...valueNode, values: valueNode.values.map(sortValueNode) };\n\n    case Kind.INT:\n    case Kind.FLOAT:\n    case Kind.STRING:\n    case Kind.BOOLEAN:\n    case Kind.NULL:\n    case Kind.ENUM:\n    case Kind.VARIABLE:\n      return valueNode;\n  }\n}\n\nfunction sortFields(fields) {\n  return fields\n    .map((fieldNode) => ({\n      ...fieldNode,\n      value: sortValueNode(fieldNode.value),\n    }))\n    .sort((fieldA, fieldB) =>\n      naturalCompare(fieldA.name.value, fieldB.name.value),\n    );\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  isInterfaceType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../../type/definition.mjs';\nimport { sortValueNode } from '../../utilities/sortValueNode.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason\n      .map(\n        ([responseName, subReason]) =>\n          `subfields \"${responseName}\" conflict because ` +\n          reasonMessage(subReason),\n      )\n      .join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\n */\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  const cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(\n        context,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        context.getParentType(),\n        selectionSet,\n      );\n\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(\n          new GraphQLError(\n            `Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,\n            {\n              nodes: fields1.concat(fields2),\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentType,\n  selectionSet,\n) {\n  const conflicts = [];\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType,\n    selectionSet,\n  ); // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    fieldMap,\n  );\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (let i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        false,\n        fieldMap,\n        fragmentNames[i],\n      ); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (let j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(\n          context,\n          conflicts,\n          cachedFieldsAndFragmentNames,\n          comparedFragmentPairs,\n          false,\n          fragmentNames[i],\n          fragmentNames[j],\n        );\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\nfunction collectConflictsBetweenFieldsAndFragment(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fieldMap,\n  fragmentName,\n) {\n  const fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  const [fieldMap2, referencedFragmentNames] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment,\n    ); // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap,\n    fieldMap2,\n  ); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (const referencedFragmentName of referencedFragmentNames) {\n    // Memoize so two fragments are not compared for conflicts more than once.\n    if (\n      comparedFragmentPairs.has(\n        referencedFragmentName,\n        fragmentName,\n        areMutuallyExclusive,\n      )\n    ) {\n      continue;\n    }\n\n    comparedFragmentPairs.add(\n      referencedFragmentName,\n      fragmentName,\n      areMutuallyExclusive,\n    );\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap,\n      referencedFragmentName,\n    );\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\nfunction collectConflictsBetweenFragments(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fragmentName1,\n  fragmentName2,\n) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n  if (\n    comparedFragmentPairs.has(\n      fragmentName1,\n      fragmentName2,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  const [fieldMap1, referencedFragmentNames1] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment1,\n    );\n  const [fieldMap2, referencedFragmentNames2] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment2,\n    ); // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fragmentName1,\n      referencedFragmentName2,\n    );\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      referencedFragmentName1,\n      fragmentName2,\n    );\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\nfunction findConflictsBetweenSubSelectionSets(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  parentType1,\n  selectionSet1,\n  parentType2,\n  selectionSet2,\n) {\n  const conflicts = [];\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType1,\n    selectionSet1,\n  );\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType2,\n    selectionSet2,\n  ); // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  for (const fragmentName2 of fragmentNames2) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap1,\n      fragmentName2,\n    );\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n  for (const fragmentName1 of fragmentNames1) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap2,\n      fragmentName1,\n    );\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n  for (const fragmentName1 of fragmentNames1) {\n    for (const fragmentName2 of fragmentNames2) {\n      collectConflictsBetweenFragments(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        areMutuallyExclusive,\n        fragmentName1,\n        fragmentName2,\n      );\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\nfunction collectConflictsWithin(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  fieldMap,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            false, // within one collection is never mutually exclusive\n            responseName,\n            fields[i],\n            fields[j],\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\nfunction collectConflictsBetween(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  fieldMap1,\n  fieldMap2,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\n    const fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            parentFieldsAreMutuallyExclusive,\n            responseName,\n            field1,\n            field2,\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\nfunction findConflict(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  responseName,\n  field1,\n  field2,\n) {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  const areMutuallyExclusive =\n    parentFieldsAreMutuallyExclusive ||\n    (parentType1 !== parentType2 &&\n      isObjectType(parentType1) &&\n      isObjectType(parentType2));\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [\n        [responseName, `\"${name1}\" and \"${name2}\" are different fields`],\n        [node1],\n        [node2],\n      ];\n    } // Two field calls must have the same arguments.\n\n    if (!sameArguments(node1, node2)) {\n      return [\n        [responseName, 'they have differing arguments'],\n        [node1],\n        [node2],\n      ];\n    }\n  } // The return type for each field.\n\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [\n      [\n        responseName,\n        `they return conflicting types \"${inspect(type1)}\" and \"${inspect(\n          type2,\n        )}\"`,\n      ],\n      [node1],\n      [node2],\n    ];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(\n      context,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      getNamedType(type1),\n      selectionSet1,\n      getNamedType(type2),\n      selectionSet2,\n    );\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(node1, node2) {\n  const args1 = node1.arguments;\n  const args2 = node2.arguments;\n\n  if (args1 === undefined || args1.length === 0) {\n    return args2 === undefined || args2.length === 0;\n  }\n\n  if (args2 === undefined || args2.length === 0) {\n    return false;\n  }\n  /* c8 ignore next */\n\n  if (args1.length !== args2.length) {\n    /* c8 ignore next */\n    return false;\n    /* c8 ignore next */\n  }\n\n  const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));\n  return args1.every((arg1) => {\n    const value1 = arg1.value;\n    const value2 = values2.get(arg1.name.value);\n\n    if (value2 === undefined) {\n      return false;\n    }\n\n    return stringifyValue(value1) === stringifyValue(value2);\n  });\n}\n\nfunction stringifyValue(value) {\n  return print(sortValueNode(value));\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\nfunction getFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  parentType,\n  selectionSet,\n) {\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const nodeAndDefs = Object.create(null);\n  const fragmentNames = Object.create(null);\n\n  _collectFieldsAndFragmentNames(\n    context,\n    parentType,\n    selectionSet,\n    nodeAndDefs,\n    fragmentNames,\n  );\n\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\nfunction getReferencedFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  fragment,\n) {\n  // Short-circuit building a type from the node if possible.\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    fragmentType,\n    fragment.selectionSet,\n  );\n}\n\nfunction _collectFieldsAndFragmentNames(\n  context,\n  parentType,\n  selectionSet,\n  nodeAndDefs,\n  fragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        const fieldName = selection.name.value;\n        let fieldDef;\n\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        const responseName = selection.alias\n          ? selection.alias.value\n          : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT: {\n        const typeCondition = selection.typeCondition;\n        const inlineFragmentType = typeCondition\n          ? typeFromAST(context.getSchema(), typeCondition)\n          : parentType;\n\n        _collectFieldsAndFragmentNames(\n          context,\n          inlineFragmentType,\n          selection.selectionSet,\n          nodeAndDefs,\n          fragmentNames,\n        );\n\n        break;\n      }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [\n      [responseName, conflicts.map(([reason]) => reason)],\n      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],\n      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()],\n    ];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does not matter.\n */\n\nclass PairSet {\n  constructor() {\n    this._data = new Map();\n  }\n\n  has(a, b, areMutuallyExclusive) {\n    var _this$_data$get;\n\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n    const result =\n      (_this$_data$get = this._data.get(key1)) === null ||\n      _this$_data$get === void 0\n        ? void 0\n        : _this$_data$get.get(key2);\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true, hence if\n    // we want to know if this PairSet \"has\" these two with no exclusivity,\n    // we have to ensure it was added as such.\n\n    return areMutuallyExclusive ? true : areMutuallyExclusive === result;\n  }\n\n  add(a, b, areMutuallyExclusive) {\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n\n    const map = this._data.get(key1);\n\n    if (map === undefined) {\n      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));\n    } else {\n      map.set(key2, areMutuallyExclusive);\n    }\n  }\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { keyMap } from '../../jsutils/keyMap.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isRequiredArgument, isType } from '../../type/definition.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Provided required arguments\n *\n * A field or directive is only valid if all required (non-null without a\n * default value) field arguments have been provided.\n */\nexport function ProvidedRequiredArgumentsRule(context) {\n  return {\n    // eslint-disable-next-line new-cap\n    ...ProvidedRequiredArgumentsOnDirectivesRule(context),\n    Field: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave(fieldNode) {\n        var _fieldNode$arguments;\n\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          return false;\n        }\n\n        const providedArgs = new Set( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n          /* c8 ignore next */\n          (_fieldNode$arguments = fieldNode.arguments) === null ||\n          _fieldNode$arguments === void 0\n            ? void 0\n            : _fieldNode$arguments.map((arg) => arg.name.value),\n        );\n\n        for (const argDef of fieldDef.args) {\n          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {\n            const argTypeStr = inspect(argDef.type);\n            context.reportError(\n              new GraphQLError(\n                `Field \"${fieldDef.name}\" argument \"${argDef.name}\" of type \"${argTypeStr}\" is required, but it was not provided.`,\n                {\n                  nodes: fieldNode,\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n  };\n}\n/**\n * @internal\n */\n\nexport function ProvidedRequiredArgumentsOnDirectivesRule(context) {\n  var _schema$getDirectives;\n\n  const requiredArgsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives =\n    (_schema$getDirectives =\n      schema === null || schema === void 0\n        ? void 0\n        : schema.getDirectives()) !== null && _schema$getDirectives !== void 0\n      ? _schema$getDirectives\n      : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    requiredArgsMap[directive.name] = keyMap(\n      directive.args.filter(isRequiredArgument),\n      (arg) => arg.name,\n    );\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argNodes =\n        (_def$arguments = def.arguments) !== null && _def$arguments !== void 0\n          ? _def$arguments\n          : [];\n      requiredArgsMap[def.name.value] = keyMap(\n        argNodes.filter(isRequiredArgumentNode),\n        (arg) => arg.name.value,\n      );\n    }\n  }\n\n  return {\n    Directive: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave(directiveNode) {\n        const directiveName = directiveNode.name.value;\n        const requiredArgs = requiredArgsMap[directiveName];\n\n        if (requiredArgs) {\n          var _directiveNode$argume;\n\n          // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n          /* c8 ignore next */\n          const argNodes =\n            (_directiveNode$argume = directiveNode.arguments) !== null &&\n            _directiveNode$argume !== void 0\n              ? _directiveNode$argume\n              : [];\n          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));\n\n          for (const [argName, argDef] of Object.entries(requiredArgs)) {\n            if (!argNodeMap.has(argName)) {\n              const argType = isType(argDef.type)\n                ? inspect(argDef.type)\n                : print(argDef.type);\n              context.reportError(\n                new GraphQLError(\n                  `Directive \"@${directiveName}\" argument \"${argName}\" of type \"${argType}\" is required, but it was not provided.`,\n                  {\n                    nodes: directiveNode,\n                  },\n                ),\n              );\n            }\n          }\n        }\n      },\n    },\n  };\n}\n\nfunction isRequiredArgumentNode(arg) {\n  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;\n}\n","import { inspect } from '../jsutils/inspect.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { printPathArray } from '../jsutils/printPathArray.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { print } from '../language/printer.mjs';\nimport { isInputType, isNonNullType } from '../type/definition.mjs';\nimport { coerceInputValue } from '../utilities/coerceInputValue.mjs';\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\nimport { valueFromAST } from '../utilities/valueFromAST.mjs';\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getVariableValues(schema, varDefNodes, inputs, options) {\n  const errors = [];\n  const maxErrors =\n    options === null || options === void 0 ? void 0 : options.maxErrors;\n\n  try {\n    const coerced = coerceVariableValues(\n      schema,\n      varDefNodes,\n      inputs,\n      (error) => {\n        if (maxErrors != null && errors.length >= maxErrors) {\n          throw new GraphQLError(\n            'Too many errors processing variables, error limit reached. Execution aborted.',\n          );\n        }\n\n        errors.push(error);\n      },\n    );\n\n    if (errors.length === 0) {\n      return {\n        coerced,\n      };\n    }\n  } catch (error) {\n    errors.push(error);\n  }\n\n  return {\n    errors,\n  };\n}\n\nfunction coerceVariableValues(schema, varDefNodes, inputs, onError) {\n  const coercedValues = {};\n\n  for (const varDefNode of varDefNodes) {\n    const varName = varDefNode.variable.name.value;\n    const varType = typeFromAST(schema, varDefNode.type);\n\n    if (!isInputType(varType)) {\n      // Must use input types for variables. This should be caught during\n      // validation, however is checked again here for safety.\n      const varTypeStr = print(varDefNode.type);\n      onError(\n        new GraphQLError(\n          `Variable \"$${varName}\" expected value of type \"${varTypeStr}\" which cannot be used as an input type.`,\n          {\n            nodes: varDefNode.type,\n          },\n        ),\n      );\n      continue;\n    }\n\n    if (!hasOwnProperty(inputs, varName)) {\n      if (varDefNode.defaultValue) {\n        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);\n      } else if (isNonNullType(varType)) {\n        const varTypeStr = inspect(varType);\n        onError(\n          new GraphQLError(\n            `Variable \"$${varName}\" of required type \"${varTypeStr}\" was not provided.`,\n            {\n              nodes: varDefNode,\n            },\n          ),\n        );\n      }\n\n      continue;\n    }\n\n    const value = inputs[varName];\n\n    if (value === null && isNonNullType(varType)) {\n      const varTypeStr = inspect(varType);\n      onError(\n        new GraphQLError(\n          `Variable \"$${varName}\" of non-null type \"${varTypeStr}\" must not be null.`,\n          {\n            nodes: varDefNode,\n          },\n        ),\n      );\n      continue;\n    }\n\n    coercedValues[varName] = coerceInputValue(\n      value,\n      varType,\n      (path, invalidValue, error) => {\n        let prefix =\n          `Variable \"$${varName}\" got invalid value ` + inspect(invalidValue);\n\n        if (path.length > 0) {\n          prefix += ` at \"${varName}${printPathArray(path)}\"`;\n        }\n\n        onError(\n          new GraphQLError(prefix + '; ' + error.message, {\n            nodes: varDefNode,\n            originalError: error,\n          }),\n        );\n      },\n    );\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getArgumentValues(def, node, variableValues) {\n  var _node$arguments;\n\n  const coercedValues = {}; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const argumentNodes =\n    (_node$arguments = node.arguments) !== null && _node$arguments !== void 0\n      ? _node$arguments\n      : [];\n  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);\n\n  for (const argDef of def.args) {\n    const name = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (argDef.defaultValue !== undefined) {\n        coercedValues[name] = argDef.defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError(\n          `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n            'was not provided.',\n          {\n            nodes: node,\n          },\n        );\n      }\n\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === Kind.NULL;\n\n    if (valueNode.kind === Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n\n      if (\n        variableValues == null ||\n        !hasOwnProperty(variableValues, variableName)\n      ) {\n        if (argDef.defaultValue !== undefined) {\n          coercedValues[name] = argDef.defaultValue;\n        } else if (isNonNullType(argType)) {\n          throw new GraphQLError(\n            `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n              `was provided the variable \"$${variableName}\" which was not provided a runtime value.`,\n            {\n              nodes: valueNode,\n            },\n          );\n        }\n\n        continue;\n      }\n\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && isNonNullType(argType)) {\n      throw new GraphQLError(\n        `Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` +\n          'must not be null.',\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    const coercedValue = valueFromAST(valueNode, argType, variableValues);\n\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new GraphQLError(\n        `Argument \"${name}\" has invalid value ${print(valueNode)}.`,\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    coercedValues[name] = coercedValue;\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getDirectiveValues(directiveDef, node, variableValues) {\n  var _node$directives;\n\n  const directiveNode =\n    (_node$directives = node.directives) === null || _node$directives === void 0\n      ? void 0\n      : _node$directives.find(\n          (directive) => directive.name.value === directiveDef.name,\n        );\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","import { Kind } from '../language/kinds.mjs';\nimport { isAbstractType } from '../type/definition.mjs';\nimport {\n  GraphQLIncludeDirective,\n  GraphQLSkipDirective,\n} from '../type/directives.mjs';\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\nimport { getDirectiveValues } from './values.mjs';\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectFields(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n) {\n  const fields = new Map();\n  collectFieldsImpl(\n    schema,\n    fragments,\n    variableValues,\n    runtimeType,\n    selectionSet,\n    fields,\n    new Set(),\n  );\n  return fields;\n}\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectSubfields(\n  schema,\n  fragments,\n  variableValues,\n  returnType,\n  fieldNodes,\n) {\n  const subFieldNodes = new Map();\n  const visitedFragmentNames = new Set();\n\n  for (const node of fieldNodes) {\n    if (node.selectionSet) {\n      collectFieldsImpl(\n        schema,\n        fragments,\n        variableValues,\n        returnType,\n        node.selectionSet,\n        subFieldNodes,\n        visitedFragmentNames,\n      );\n    }\n  }\n\n  return subFieldNodes;\n}\n\nfunction collectFieldsImpl(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n  fields,\n  visitedFragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        if (!shouldIncludeNode(variableValues, selection)) {\n          continue;\n        }\n\n        const name = getFieldEntryKey(selection);\n        const fieldList = fields.get(name);\n\n        if (fieldList !== undefined) {\n          fieldList.push(selection);\n        } else {\n          fields.set(name, [selection]);\n        }\n\n        break;\n      }\n\n      case Kind.INLINE_FRAGMENT: {\n        if (\n          !shouldIncludeNode(variableValues, selection) ||\n          !doesFragmentConditionMatch(schema, selection, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          selection.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD: {\n        const fragName = selection.name.value;\n\n        if (\n          visitedFragmentNames.has(fragName) ||\n          !shouldIncludeNode(variableValues, selection)\n        ) {\n          continue;\n        }\n\n        visitedFragmentNames.add(fragName);\n        const fragment = fragments[fragName];\n\n        if (\n          !fragment ||\n          !doesFragmentConditionMatch(schema, fragment, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          fragment.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n    }\n  }\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n\n  const include = getDirectiveValues(\n    GraphQLIncludeDirective,\n    node,\n    variableValues,\n  );\n\n  if (\n    (include === null || include === void 0 ? void 0 : include.if) === false\n  ) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  const conditionalType = typeFromAST(schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (isAbstractType(conditionalType)) {\n    return schema.isSubType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { keyMap } from '../../jsutils/keyMap.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  getNullableType,\n  isInputObjectType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isRequiredInputField,\n} from '../../type/definition.mjs';\n\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n *\n * See https://spec.graphql.org/draft/#sec-Values-of-Correct-Type\n */\nexport function ValuesOfCorrectTypeRule(context) {\n  return {\n    ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      const type = getNullableType(context.getParentInputType());\n\n      if (!isListType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n\n    ObjectValue(node) {\n      const type = getNamedType(context.getInputType());\n\n      if (!isInputObjectType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);\n\n      for (const fieldDef of Object.values(type.getFields())) {\n        const fieldNode = fieldNodeMap[fieldDef.name];\n\n        if (!fieldNode && isRequiredInputField(fieldDef)) {\n          const typeStr = inspect(fieldDef.type);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${type.name}.${fieldDef.name}\" of required type \"${typeStr}\" was not provided.`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const parentType = getNamedType(context.getParentInputType());\n      const fieldType = context.getInputType();\n\n      if (!fieldType && isInputObjectType(parentType)) {\n        const suggestions = suggestionList(\n          node.name.value,\n          Object.keys(parentType.getFields()),\n        );\n        context.reportError(\n          new GraphQLError(\n            `Field \"${node.name.value}\" is not defined by type \"${parentType.name}\".` +\n              didYouMean(suggestions),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    NullValue(node) {\n      const type = context.getInputType();\n\n      if (isNonNullType(type)) {\n        context.reportError(\n          new GraphQLError(\n            `Expected value of type \"${inspect(type)}\", found ${print(node)}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    EnumValue: (node) => isValidValueNode(context, node),\n    IntValue: (node) => isValidValueNode(context, node),\n    FloatValue: (node) => isValidValueNode(context, node),\n    StringValue: (node) => isValidValueNode(context, node),\n    BooleanValue: (node) => isValidValueNode(context, node),\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\nfunction isValidValueNode(context, node) {\n  // Report any error at the full type expected by the location.\n  const locationType = context.getInputType();\n\n  if (!locationType) {\n    return;\n  }\n\n  const type = getNamedType(locationType);\n\n  if (!isLeafType(type)) {\n    const typeStr = inspect(locationType);\n    context.reportError(\n      new GraphQLError(\n        `Expected value of type \"${typeStr}\", found ${print(node)}.`,\n        {\n          nodes: node,\n        },\n      ),\n    );\n    return;\n  } // Scalars and Enums determine if a literal value is valid via parseLiteral(),\n  // which may throw or return an invalid value to indicate failure.\n\n  try {\n    const parseResult = type.parseLiteral(\n      node,\n      undefined,\n      /* variables */\n    );\n\n    if (parseResult === undefined) {\n      const typeStr = inspect(locationType);\n      context.reportError(\n        new GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${print(node)}.`,\n          {\n            nodes: node,\n          },\n        ),\n      );\n    }\n  } catch (error) {\n    const typeStr = inspect(locationType);\n\n    if (error instanceof GraphQLError) {\n      context.reportError(error);\n    } else {\n      context.reportError(\n        new GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${print(node)}; ` +\n            error.message,\n          {\n            nodes: node,\n            originalError: error,\n          },\n        ),\n      );\n    }\n  }\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isNonNullType } from '../../type/definition.mjs';\nimport { isTypeSubTypeOf } from '../../utilities/typeComparators.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Variables in allowed position\n *\n * Variable usages must be compatible with the arguments they are passed to.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variable-Usages-are-Allowed\n */\nexport function VariablesInAllowedPositionRule(context) {\n  let varDefMap = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        varDefMap = Object.create(null);\n      },\n\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node, type, defaultValue } of usages) {\n          const varName = node.name.value;\n          const varDef = varDefMap[varName];\n\n          if (varDef && type) {\n            // A var type is allowed if it is the same or more strict (e.g. is\n            // a subtype of) than the expected type. It can be more strict if\n            // the variable type is non-null when the expected type is nullable.\n            // If both are list types, the variable item type can be more strict\n            // than the expected item type (contravariant).\n            const schema = context.getSchema();\n            const varType = typeFromAST(schema, varDef.type);\n\n            if (\n              varType &&\n              !allowedVariableUsage(\n                schema,\n                varType,\n                varDef.defaultValue,\n                type,\n                defaultValue,\n              )\n            ) {\n              const varTypeStr = inspect(varType);\n              const typeStr = inspect(type);\n              context.reportError(\n                new GraphQLError(\n                  `Variable \"$${varName}\" of type \"${varTypeStr}\" used in position expecting type \"${typeStr}\".`,\n                  {\n                    nodes: [varDef, node],\n                  },\n                ),\n              );\n            }\n          }\n        }\n      },\n    },\n\n    VariableDefinition(node) {\n      varDefMap[node.variable.name.value] = node;\n    },\n  };\n}\n/**\n * Returns true if the variable is allowed in the location it was found,\n * which includes considering if default values exist for either the variable\n * or the location at which it is located.\n */\n\nfunction allowedVariableUsage(\n  schema,\n  varType,\n  varDefaultValue,\n  locationType,\n  locationDefaultValue,\n) {\n  if (isNonNullType(locationType) && !isNonNullType(varType)) {\n    const hasNonNullVariableDefaultValue =\n      varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;\n    const hasLocationDefaultValue = locationDefaultValue !== undefined;\n\n    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {\n      return false;\n    }\n\n    const nullableLocationType = locationType.ofType;\n    return isTypeSubTypeOf(schema, varType, nullableLocationType);\n  }\n\n  return isTypeSubTypeOf(schema, varType, locationType);\n}\n","// Spec Section: \"Executable Definitions\"\nimport { ExecutableDefinitionsRule } from './rules/ExecutableDefinitionsRule.mjs'; // Spec Section: \"Field Selections on Objects, Interfaces, and Unions Types\"\n\nimport { FieldsOnCorrectTypeRule } from './rules/FieldsOnCorrectTypeRule.mjs'; // Spec Section: \"Fragments on Composite Types\"\n\nimport { FragmentsOnCompositeTypesRule } from './rules/FragmentsOnCompositeTypesRule.mjs'; // Spec Section: \"Argument Names\"\n\nimport {\n  KnownArgumentNamesOnDirectivesRule,\n  KnownArgumentNamesRule,\n} from './rules/KnownArgumentNamesRule.mjs'; // Spec Section: \"Directives Are Defined\"\n\nimport { KnownDirectivesRule } from './rules/KnownDirectivesRule.mjs'; // Spec Section: \"Fragment spread target defined\"\n\nimport { KnownFragmentNamesRule } from './rules/KnownFragmentNamesRule.mjs'; // Spec Section: \"Fragment Spread Type Existence\"\n\nimport { KnownTypeNamesRule } from './rules/KnownTypeNamesRule.mjs'; // Spec Section: \"Lone Anonymous Operation\"\n\nimport { LoneAnonymousOperationRule } from './rules/LoneAnonymousOperationRule.mjs'; // SDL-specific validation rules\n\nimport { LoneSchemaDefinitionRule } from './rules/LoneSchemaDefinitionRule.mjs'; // Spec Section: \"Fragments must not form cycles\"\n\nimport { NoFragmentCyclesRule } from './rules/NoFragmentCyclesRule.mjs'; // Spec Section: \"All Variable Used Defined\"\n\nimport { NoUndefinedVariablesRule } from './rules/NoUndefinedVariablesRule.mjs'; // Spec Section: \"Fragments must be used\"\n\nimport { NoUnusedFragmentsRule } from './rules/NoUnusedFragmentsRule.mjs'; // Spec Section: \"All Variables Used\"\n\nimport { NoUnusedVariablesRule } from './rules/NoUnusedVariablesRule.mjs'; // Spec Section: \"Field Selection Merging\"\n\nimport { OverlappingFieldsCanBeMergedRule } from './rules/OverlappingFieldsCanBeMergedRule.mjs'; // Spec Section: \"Fragment spread is possible\"\n\nimport { PossibleFragmentSpreadsRule } from './rules/PossibleFragmentSpreadsRule.mjs';\nimport { PossibleTypeExtensionsRule } from './rules/PossibleTypeExtensionsRule.mjs'; // Spec Section: \"Argument Optionality\"\n\nimport {\n  ProvidedRequiredArgumentsOnDirectivesRule,\n  ProvidedRequiredArgumentsRule,\n} from './rules/ProvidedRequiredArgumentsRule.mjs'; // Spec Section: \"Leaf Field Selections\"\n\nimport { ScalarLeafsRule } from './rules/ScalarLeafsRule.mjs'; // Spec Section: \"Subscriptions with Single Root Field\"\n\nimport { SingleFieldSubscriptionsRule } from './rules/SingleFieldSubscriptionsRule.mjs';\nimport { UniqueArgumentDefinitionNamesRule } from './rules/UniqueArgumentDefinitionNamesRule.mjs'; // Spec Section: \"Argument Uniqueness\"\n\nimport { UniqueArgumentNamesRule } from './rules/UniqueArgumentNamesRule.mjs';\nimport { UniqueDirectiveNamesRule } from './rules/UniqueDirectiveNamesRule.mjs'; // Spec Section: \"Directives Are Unique Per Location\"\n\nimport { UniqueDirectivesPerLocationRule } from './rules/UniqueDirectivesPerLocationRule.mjs';\nimport { UniqueEnumValueNamesRule } from './rules/UniqueEnumValueNamesRule.mjs';\nimport { UniqueFieldDefinitionNamesRule } from './rules/UniqueFieldDefinitionNamesRule.mjs'; // Spec Section: \"Fragment Name Uniqueness\"\n\nimport { UniqueFragmentNamesRule } from './rules/UniqueFragmentNamesRule.mjs'; // Spec Section: \"Input Object Field Uniqueness\"\n\nimport { UniqueInputFieldNamesRule } from './rules/UniqueInputFieldNamesRule.mjs'; // Spec Section: \"Operation Name Uniqueness\"\n\nimport { UniqueOperationNamesRule } from './rules/UniqueOperationNamesRule.mjs';\nimport { UniqueOperationTypesRule } from './rules/UniqueOperationTypesRule.mjs';\nimport { UniqueTypeNamesRule } from './rules/UniqueTypeNamesRule.mjs'; // Spec Section: \"Variable Uniqueness\"\n\nimport { UniqueVariableNamesRule } from './rules/UniqueVariableNamesRule.mjs'; // Spec Section: \"Value Type Correctness\"\n\nimport { ValuesOfCorrectTypeRule } from './rules/ValuesOfCorrectTypeRule.mjs'; // Spec Section: \"Variables are Input Types\"\n\nimport { VariablesAreInputTypesRule } from './rules/VariablesAreInputTypesRule.mjs'; // Spec Section: \"All Variable Usages Are Allowed\"\n\nimport { VariablesInAllowedPositionRule } from './rules/VariablesInAllowedPositionRule.mjs';\n\n/**\n * This set includes all validation rules defined by the GraphQL spec.\n *\n * The order of the rules in this list has been adjusted to lead to the\n * most clear output when encountering multiple validation errors.\n */\nexport const specifiedRules = Object.freeze([\n  ExecutableDefinitionsRule,\n  UniqueOperationNamesRule,\n  LoneAnonymousOperationRule,\n  SingleFieldSubscriptionsRule,\n  KnownTypeNamesRule,\n  FragmentsOnCompositeTypesRule,\n  VariablesAreInputTypesRule,\n  ScalarLeafsRule,\n  FieldsOnCorrectTypeRule,\n  UniqueFragmentNamesRule,\n  KnownFragmentNamesRule,\n  NoUnusedFragmentsRule,\n  PossibleFragmentSpreadsRule,\n  NoFragmentCyclesRule,\n  UniqueVariableNamesRule,\n  NoUndefinedVariablesRule,\n  NoUnusedVariablesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  KnownArgumentNamesRule,\n  UniqueArgumentNamesRule,\n  ValuesOfCorrectTypeRule,\n  ProvidedRequiredArgumentsRule,\n  VariablesInAllowedPositionRule,\n  OverlappingFieldsCanBeMergedRule,\n  UniqueInputFieldNamesRule,\n]);\n/**\n * @internal\n */\n\nexport const specifiedSDLRules = Object.freeze([\n  LoneSchemaDefinitionRule,\n  UniqueOperationTypesRule,\n  UniqueTypeNamesRule,\n  UniqueEnumValueNamesRule,\n  UniqueFieldDefinitionNamesRule,\n  UniqueArgumentDefinitionNamesRule,\n  UniqueDirectiveNamesRule,\n  KnownTypeNamesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  PossibleTypeExtensionsRule,\n  KnownArgumentNamesOnDirectivesRule,\n  UniqueArgumentNamesRule,\n  UniqueInputFieldNamesRule,\n  ProvidedRequiredArgumentsOnDirectivesRule,\n]);\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique operation names\n *\n * A GraphQL document is only valid if all defined operations have unique names.\n *\n * See https://spec.graphql.org/draft/#sec-Operation-Name-Uniqueness\n */\nexport function UniqueOperationNamesRule(context) {\n  const knownOperationNames = Object.create(null);\n  return {\n    OperationDefinition(node) {\n      const operationName = node.name;\n\n      if (operationName) {\n        if (knownOperationNames[operationName.value]) {\n          context.reportError(\n            new GraphQLError(\n              `There can be only one operation named \"${operationName.value}\".`,\n              {\n                nodes: [\n                  knownOperationNames[operationName.value],\n                  operationName,\n                ],\n              },\n            ),\n          );\n        } else {\n          knownOperationNames[operationName.value] = operationName;\n        }\n      }\n\n      return false;\n    },\n\n    FragmentDefinition: () => false,\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\n\n/**\n * Lone anonymous operation\n *\n * A GraphQL document is only valid if when it contains an anonymous operation\n * (the query short-hand) that it contains only that one operation definition.\n *\n * See https://spec.graphql.org/draft/#sec-Lone-Anonymous-Operation\n */\nexport function LoneAnonymousOperationRule(context) {\n  let operationCount = 0;\n  return {\n    Document(node) {\n      operationCount = node.definitions.filter(\n        (definition) => definition.kind === Kind.OPERATION_DEFINITION,\n      ).length;\n    },\n\n    OperationDefinition(node) {\n      if (!node.name && operationCount > 1) {\n        context.reportError(\n          new GraphQLError(\n            'This anonymous operation must be the only defined operation.',\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { collectFields } from '../../execution/collectFields.mjs';\n\n/**\n * Subscriptions must only include a non-introspection field.\n *\n * A GraphQL subscription is valid only if it contains a single root field and\n * that root field is not an introspection field.\n *\n * See https://spec.graphql.org/draft/#sec-Single-root-field\n */\nexport function SingleFieldSubscriptionsRule(context) {\n  return {\n    OperationDefinition(node) {\n      if (node.operation === 'subscription') {\n        const schema = context.getSchema();\n        const subscriptionType = schema.getSubscriptionType();\n\n        if (subscriptionType) {\n          const operationName = node.name ? node.name.value : null;\n          const variableValues = Object.create(null);\n          const document = context.getDocument();\n          const fragments = Object.create(null);\n\n          for (const definition of document.definitions) {\n            if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n              fragments[definition.name.value] = definition;\n            }\n          }\n\n          const fields = collectFields(\n            schema,\n            fragments,\n            variableValues,\n            subscriptionType,\n            node.selectionSet,\n          );\n\n          if (fields.size > 1) {\n            const fieldSelectionLists = [...fields.values()];\n            const extraFieldSelectionLists = fieldSelectionLists.slice(1);\n            const extraFieldSelections = extraFieldSelectionLists.flat();\n            context.reportError(\n              new GraphQLError(\n                operationName != null\n                  ? `Subscription \"${operationName}\" must select only one top level field.`\n                  : 'Anonymous Subscription must select only one top level field.',\n                {\n                  nodes: extraFieldSelections,\n                },\n              ),\n            );\n          }\n\n          for (const fieldNodes of fields.values()) {\n            const field = fieldNodes[0];\n            const fieldName = field.name.value;\n\n            if (fieldName.startsWith('__')) {\n              context.reportError(\n                new GraphQLError(\n                  operationName != null\n                    ? `Subscription \"${operationName}\" must not select an introspection top level field.`\n                    : 'Anonymous Subscription must not select an introspection top level field.',\n                  {\n                    nodes: fieldNodes,\n                  },\n                ),\n              );\n            }\n          }\n        }\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isCompositeType } from '../../type/definition.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-On-Composite-Types\n */\nexport function FragmentsOnCompositeTypesRule(context) {\n  return {\n    InlineFragment(node) {\n      const typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        const type = typeFromAST(context.getSchema(), typeCondition);\n\n        if (type && !isCompositeType(type)) {\n          const typeStr = print(typeCondition);\n          context.reportError(\n            new GraphQLError(\n              `Fragment cannot condition on non composite type \"${typeStr}\".`,\n              {\n                nodes: typeCondition,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    FragmentDefinition(node) {\n      const type = typeFromAST(context.getSchema(), node.typeCondition);\n\n      if (type && !isCompositeType(type)) {\n        const typeStr = print(node.typeCondition);\n        context.reportError(\n          new GraphQLError(\n            `Fragment \"${node.name.value}\" cannot condition on non composite type \"${typeStr}\".`,\n            {\n              nodes: node.typeCondition,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isInputType } from '../../type/definition.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Variables are input types\n *\n * A GraphQL operation is only valid if all the variables it defines are of\n * input types (scalar, enum, or input object).\n *\n * See https://spec.graphql.org/draft/#sec-Variables-Are-Input-Types\n */\nexport function VariablesAreInputTypesRule(context) {\n  return {\n    VariableDefinition(node) {\n      const type = typeFromAST(context.getSchema(), node.type);\n\n      if (type !== undefined && !isInputType(type)) {\n        const variableName = node.variable.name.value;\n        const typeName = print(node.type);\n        context.reportError(\n          new GraphQLError(\n            `Variable \"$${variableName}\" cannot be non-input type \"${typeName}\".`,\n            {\n              nodes: node.type,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { getNamedType, isLeafType } from '../../type/definition.mjs';\n\n/**\n * Scalar leafs\n *\n * A GraphQL document is valid only if all leaf fields (fields without\n * sub selections) are of scalar or enum types.\n */\nexport function ScalarLeafsRule(context) {\n  return {\n    Field(node) {\n      const type = context.getType();\n      const selectionSet = node.selectionSet;\n\n      if (type) {\n        if (isLeafType(getNamedType(type))) {\n          if (selectionSet) {\n            const fieldName = node.name.value;\n            const typeStr = inspect(type);\n            context.reportError(\n              new GraphQLError(\n                `Field \"${fieldName}\" must not have a selection since type \"${typeStr}\" has no subfields.`,\n                {\n                  nodes: selectionSet,\n                },\n              ),\n            );\n          }\n        } else if (!selectionSet) {\n          const fieldName = node.name.value;\n          const typeStr = inspect(type);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${fieldName}\" of type \"${typeStr}\" must have a selection of subfields. Did you mean \"${fieldName} { ... }\"?`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { naturalCompare } from '../../jsutils/naturalCompare.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isAbstractType,\n  isInterfaceType,\n  isObjectType,\n} from '../../type/definition.mjs';\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selections\n */\nexport function FieldsOnCorrectTypeRule(context) {\n  return {\n    Field(node) {\n      const type = context.getParentType();\n\n      if (type) {\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          const schema = context.getSchema();\n          const fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          let suggestion = didYouMean(\n            'to use an inline fragment on',\n            getSuggestedTypeNames(schema, type, fieldName),\n          ); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n          context.reportError(\n            new GraphQLError(\n              `Cannot query field \"${fieldName}\" on type \"${type.name}\".` +\n                suggestion,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  const suggestedTypes = new Set();\n  const usageCount = Object.create(null);\n\n  for (const possibleType of schema.getPossibleTypes(type)) {\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (const possibleInterface of possibleType.getInterfaces()) {\n      var _usageCount$possibleI;\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] =\n        ((_usageCount$possibleI = usageCount[possibleInterface.name]) !==\n          null && _usageCount$possibleI !== void 0\n          ? _usageCount$possibleI\n          : 0) + 1;\n    }\n  }\n\n  return [...suggestedTypes]\n    .sort((typeA, typeB) => {\n      // Suggest both interface and object types based on how common they are.\n      const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n      if (usageCountDiff !== 0) {\n        return usageCountDiff;\n      } // Suggest super types first followed by subtypes\n\n      if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n        return -1;\n      }\n\n      if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n        return 1;\n      }\n\n      return naturalCompare(typeA.name, typeB.name);\n    })\n    .map((x) => x.name);\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    const possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n  return [];\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique fragment names\n *\n * A GraphQL document is only valid if all defined fragments have unique names.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Name-Uniqueness\n */\nexport function UniqueFragmentNamesRule(context) {\n  const knownFragmentNames = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      const fragmentName = node.name.value;\n\n      if (knownFragmentNames[fragmentName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one fragment named \"${fragmentName}\".`,\n            {\n              nodes: [knownFragmentNames[fragmentName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownFragmentNames[fragmentName] = node.name;\n      }\n\n      return false;\n    },\n  };\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { isCompositeType } from '../../type/definition.mjs';\nimport { doTypesOverlap } from '../../utilities/typeComparators.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nexport function PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment(node) {\n      const fragType = context.getType();\n      const parentType = context.getParentType();\n\n      if (\n        isCompositeType(fragType) &&\n        isCompositeType(parentType) &&\n        !doTypesOverlap(context.getSchema(), fragType, parentType)\n      ) {\n        const parentTypeStr = inspect(parentType);\n        const fragTypeStr = inspect(fragType);\n        context.reportError(\n          new GraphQLError(\n            `Fragment cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    FragmentSpread(node) {\n      const fragName = node.name.value;\n      const fragType = getFragmentType(context, fragName);\n      const parentType = context.getParentType();\n\n      if (\n        fragType &&\n        parentType &&\n        !doTypesOverlap(context.getSchema(), fragType, parentType)\n      ) {\n        const parentTypeStr = inspect(parentType);\n        const fragTypeStr = inspect(fragType);\n        context.reportError(\n          new GraphQLError(\n            `Fragment \"${fragName}\" cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getFragmentType(context, name) {\n  const frag = context.getFragment(name);\n\n  if (frag) {\n    const type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No fragment cycles\n *\n * The graph of fragment spreads must not form any cycles including spreading itself.\n * Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spreads-must-not-form-cycles\n */\nexport function NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  const spreadPath = []; // Position in the spread path\n\n  const spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    },\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    const fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (const spreadNode of spreadNodes) {\n      const spreadName = spreadNode.name.value;\n      const cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        const spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        const cyclePath = spreadPath.slice(cycleIndex);\n        const viaPath = cyclePath\n          .slice(0, -1)\n          .map((s) => '\"' + s.name.value + '\"')\n          .join(', ');\n        context.reportError(\n          new GraphQLError(\n            `Cannot spread fragment \"${spreadName}\" within itself` +\n              (viaPath !== '' ? ` via ${viaPath}.` : '.'),\n            {\n              nodes: cyclePath,\n            },\n          ),\n        );\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n","import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique variable names\n *\n * A GraphQL operation is only valid if all its variables are uniquely named.\n */\nexport function UniqueVariableNamesRule(context) {\n  return {\n    OperationDefinition(operationNode) {\n      var _operationNode$variab;\n\n      // See: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const variableDefinitions =\n        (_operationNode$variab = operationNode.variableDefinitions) !== null &&\n        _operationNode$variab !== void 0\n          ? _operationNode$variab\n          : [];\n      const seenVariableDefinitions = groupBy(\n        variableDefinitions,\n        (node) => node.variable.name.value,\n      );\n\n      for (const [variableName, variableNodes] of seenVariableDefinitions) {\n        if (variableNodes.length > 1) {\n          context.reportError(\n            new GraphQLError(\n              `There can be only one variable named \"$${variableName}\".`,\n              {\n                nodes: variableNodes.map((node) => node.variable.name),\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No undefined variables\n *\n * A GraphQL operation is only valid if all variables encountered, both directly\n * and via fragment spreads, are defined by that operation.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variable-Uses-Defined\n */\nexport function NoUndefinedVariablesRule(context) {\n  let variableNameDefined = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        variableNameDefined = Object.create(null);\n      },\n\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node } of usages) {\n          const varName = node.name.value;\n\n          if (variableNameDefined[varName] !== true) {\n            context.reportError(\n              new GraphQLError(\n                operation.name\n                  ? `Variable \"$${varName}\" is not defined by operation \"${operation.name.value}\".`\n                  : `Variable \"$${varName}\" is not defined.`,\n                {\n                  nodes: [node, operation],\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n\n    VariableDefinition(node) {\n      variableNameDefined[node.variable.name.value] = true;\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No unused variables\n *\n * A GraphQL operation is only valid if all variables defined by an operation\n * are used, either directly or within a spread fragment.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variables-Used\n */\nexport function NoUnusedVariablesRule(context) {\n  let variableDefs = [];\n  return {\n    OperationDefinition: {\n      enter() {\n        variableDefs = [];\n      },\n\n      leave(operation) {\n        const variableNameUsed = Object.create(null);\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node } of usages) {\n          variableNameUsed[node.name.value] = true;\n        }\n\n        for (const variableDef of variableDefs) {\n          const variableName = variableDef.variable.name.value;\n\n          if (variableNameUsed[variableName] !== true) {\n            context.reportError(\n              new GraphQLError(\n                operation.name\n                  ? `Variable \"$${variableName}\" is never used in operation \"${operation.name.value}\".`\n                  : `Variable \"$${variableName}\" is never used.`,\n                {\n                  nodes: variableDef,\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n\n    VariableDefinition(def) {\n      variableDefs.push(def);\n    },\n  };\n}\n","import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique argument definition names\n *\n * A GraphQL Object or Interface type is only valid if all its fields have uniquely named arguments.\n * A GraphQL Directive is only valid if all its arguments are uniquely named.\n */\nexport function UniqueArgumentDefinitionNamesRule(context) {\n  return {\n    DirectiveDefinition(directiveNode) {\n      var _directiveNode$argume;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argumentNodes =\n        (_directiveNode$argume = directiveNode.arguments) !== null &&\n        _directiveNode$argume !== void 0\n          ? _directiveNode$argume\n          : [];\n      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);\n    },\n\n    InterfaceTypeDefinition: checkArgUniquenessPerField,\n    InterfaceTypeExtension: checkArgUniquenessPerField,\n    ObjectTypeDefinition: checkArgUniquenessPerField,\n    ObjectTypeExtension: checkArgUniquenessPerField,\n  };\n\n  function checkArgUniquenessPerField(typeNode) {\n    var _typeNode$fields;\n\n    const typeName = typeNode.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const fieldNodes =\n      (_typeNode$fields = typeNode.fields) !== null &&\n      _typeNode$fields !== void 0\n        ? _typeNode$fields\n        : [];\n\n    for (const fieldDef of fieldNodes) {\n      var _fieldDef$arguments;\n\n      const fieldName = fieldDef.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n\n      const argumentNodes =\n        (_fieldDef$arguments = fieldDef.arguments) !== null &&\n        _fieldDef$arguments !== void 0\n          ? _fieldDef$arguments\n          : [];\n      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);\n    }\n\n    return false;\n  }\n\n  function checkArgUniqueness(parentName, argumentNodes) {\n    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);\n\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(\n          new GraphQLError(\n            `Argument \"${parentName}(${argName}:)\" can only be defined once.`,\n            {\n              nodes: argNodes.map((node) => node.name),\n            },\n          ),\n        );\n      }\n    }\n\n    return false;\n  }\n}\n","import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport class ASTValidationContext {\n  constructor(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ASTValidationContext';\n  }\n\n  reportError(error) {\n    this._onError(error);\n  }\n\n  getDocument() {\n    return this._ast;\n  }\n\n  getFragment(name) {\n    let fragments;\n\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = Object.create(null);\n\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n\n      this._fragments = fragments;\n    }\n\n    return fragments[name];\n  }\n\n  getFragmentSpreads(node) {\n    let spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit = [node];\n      let set;\n\n      while ((set = setsToVisit.pop())) {\n        for (const selection of set.selections) {\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  }\n\n  getRecursivelyReferencedFragments(operation) {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = Object.create(null);\n      const nodesToVisit = [operation.selectionSet];\n      let node;\n\n      while ((node = nodesToVisit.pop())) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            const fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  }\n}\nexport class SDLValidationContext extends ASTValidationContext {\n  constructor(ast, schema, onError) {\n    super(ast, onError);\n    this._schema = schema;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'SDLValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n}\nexport class ValidationContext extends ASTValidationContext {\n  constructor(schema, ast, typeInfo, onError) {\n    super(ast, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n\n  getVariableUsages(node) {\n    let usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      const newUsages = [];\n      const typeInfo = new TypeInfo(this._schema);\n      visit(\n        node,\n        visitWithTypeInfo(typeInfo, {\n          VariableDefinition: () => false,\n\n          Variable(variable) {\n            newUsages.push({\n              node: variable,\n              type: typeInfo.getInputType(),\n              defaultValue: typeInfo.getDefaultValue(),\n            });\n          },\n        }),\n      );\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  }\n\n  getRecursiveVariableUsages(operation) {\n    let usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  }\n\n  getType() {\n    return this._typeInfo.getType();\n  }\n\n  getParentType() {\n    return this._typeInfo.getParentType();\n  }\n\n  getInputType() {\n    return this._typeInfo.getInputType();\n  }\n\n  getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  }\n\n  getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  }\n\n  getDirective() {\n    return this._typeInfo.getDirective();\n  }\n\n  getArgument() {\n    return this._typeInfo.getArgument();\n  }\n\n  getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  }\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { visit, visitInParallel } from '../language/visitor.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\nimport { specifiedRules, specifiedSDLRules } from './specifiedRules.mjs';\nimport {\n  SDLValidationContext,\n  ValidationContext,\n} from './ValidationContext.mjs';\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Validate will stop validation after a `maxErrors` limit has been reached.\n * Attackers can send pathologically invalid queries to induce a DoS attack,\n * so by default `maxErrors` set to 100 errors.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(\n  schema,\n  documentAST,\n  rules = specifiedRules,\n  options,\n  /** @deprecated will be removed in 17.0.0 */\n  typeInfo = new TypeInfo(schema),\n) {\n  var _options$maxErrors;\n\n  const maxErrors =\n    (_options$maxErrors =\n      options === null || options === void 0 ? void 0 : options.maxErrors) !==\n      null && _options$maxErrors !== void 0\n      ? _options$maxErrors\n      : 100;\n  documentAST || devAssert(false, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  const abortObj = Object.freeze({});\n  const errors = [];\n  const context = new ValidationContext(\n    schema,\n    documentAST,\n    typeInfo,\n    (error) => {\n      if (errors.length >= maxErrors) {\n        errors.push(\n          new GraphQLError(\n            'Too many validation errors, error limit reached. Validation aborted.',\n          ),\n        ); // eslint-disable-next-line @typescript-eslint/no-throw-literal\n\n        throw abortObj;\n      }\n\n      errors.push(error);\n    },\n  ); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  const visitor = visitInParallel(rules.map((rule) => rule(context))); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n}\n/**\n * @internal\n */\n\nexport function validateSDL(\n  documentAST,\n  schemaToExtend,\n  rules = specifiedSDLRules,\n) {\n  const errors = [];\n  const context = new SDLValidationContext(\n    documentAST,\n    schemaToExtend,\n    (error) => {\n      errors.push(error);\n    },\n  );\n  const visitors = rules.map((rule) => rule(context));\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  const errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  const errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n","import { invariant } from '../../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType, isInputObjectType } from '../../../type/definition.mjs';\n\n/**\n * No deprecated\n *\n * A GraphQL document is only valid if all selected fields and all used enum values have not been\n * deprecated.\n *\n * Note: This rule is optional and is not part of the Validation section of the GraphQL\n * Specification. The main purpose of this rule is detection of deprecated usages and not\n * necessarily to forbid their use when querying a service.\n */\nexport function NoDeprecatedCustomRule(context) {\n  return {\n    Field(node) {\n      const fieldDef = context.getFieldDef();\n      const deprecationReason =\n        fieldDef === null || fieldDef === void 0\n          ? void 0\n          : fieldDef.deprecationReason;\n\n      if (fieldDef && deprecationReason != null) {\n        const parentType = context.getParentType();\n        parentType != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    Argument(node) {\n      const argDef = context.getArgument();\n      const deprecationReason =\n        argDef === null || argDef === void 0\n          ? void 0\n          : argDef.deprecationReason;\n\n      if (argDef && deprecationReason != null) {\n        const directiveDef = context.getDirective();\n\n        if (directiveDef != null) {\n          context.reportError(\n            new GraphQLError(\n              `Directive \"@${directiveDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        } else {\n          const parentType = context.getParentType();\n          const fieldDef = context.getFieldDef();\n          (parentType != null && fieldDef != null) || invariant(false);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${parentType.name}.${fieldDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const inputObjectDef = getNamedType(context.getParentInputType());\n\n      if (isInputObjectType(inputObjectDef)) {\n        const inputFieldDef = inputObjectDef.getFields()[node.name.value];\n        const deprecationReason =\n          inputFieldDef === null || inputFieldDef === void 0\n            ? void 0\n            : inputFieldDef.deprecationReason;\n\n        if (deprecationReason != null) {\n          context.reportError(\n            new GraphQLError(\n              `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    EnumValue(node) {\n      const enumValueDef = context.getEnumValue();\n      const deprecationReason =\n        enumValueDef === null || enumValueDef === void 0\n          ? void 0\n          : enumValueDef.deprecationReason;\n\n      if (enumValueDef && deprecationReason != null) {\n        const enumTypeDef = getNamedType(context.getInputType());\n        enumTypeDef != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The enum value \"${enumTypeDef.name}.${enumValueDef.name}\" is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { specifiedRules, validate, NoUnusedFragmentsRule, KnownFragmentNamesRule, Kind, ExecutableDefinitionsRule, LoneSchemaDefinitionRule, UniqueOperationTypesRule, UniqueTypeNamesRule, UniqueEnumValueNamesRule, UniqueFieldDefinitionNamesRule, UniqueDirectiveNamesRule, KnownTypeNamesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, PossibleTypeExtensionsRule, UniqueArgumentNamesRule, UniqueInputFieldNamesRule, } from 'graphql';\nconst specifiedSDLRules = [\n    LoneSchemaDefinitionRule,\n    UniqueOperationTypesRule,\n    UniqueTypeNamesRule,\n    UniqueEnumValueNamesRule,\n    UniqueFieldDefinitionNamesRule,\n    UniqueDirectiveNamesRule,\n    KnownTypeNamesRule,\n    KnownDirectivesRule,\n    UniqueDirectivesPerLocationRule,\n    PossibleTypeExtensionsRule,\n    UniqueArgumentNamesRule,\n    UniqueInputFieldNamesRule,\n];\nexport function validateWithCustomRules(schema, ast, customRules, isRelayCompatMode, isSchemaDocument) {\n    const rules = specifiedRules.filter(rule => {\n        if (rule === NoUnusedFragmentsRule || rule === ExecutableDefinitionsRule) {\n            return false;\n        }\n        if (isRelayCompatMode && rule === KnownFragmentNamesRule) {\n            return false;\n        }\n        return true;\n    });\n    if (customRules) {\n        Array.prototype.push.apply(rules, customRules);\n    }\n    if (isSchemaDocument) {\n        Array.prototype.push.apply(rules, specifiedSDLRules);\n    }\n    const errors = validate(schema, ast, rules);\n    return errors.filter(error => {\n        if (error.message.includes('Unknown directive') && error.nodes) {\n            const node = error.nodes[0];\n            if (node && node.kind === Kind.DIRECTIVE) {\n                const name = node.name.value;\n                if (name === 'arguments' || name === 'argumentDefinitions') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    });\n}\n//# sourceMappingURL=validateWithCustomRules.js.map","import { GraphQLError, print, validate, NoDeprecatedCustomRule, parse, } from 'graphql';\nimport { CharacterStream, onlineParser } from '../parser';\nimport { Range, validateWithCustomRules, Position } from '../utils';\nexport const SEVERITY = {\n    Error: 'Error',\n    Warning: 'Warning',\n    Information: 'Information',\n    Hint: 'Hint',\n};\nexport const DIAGNOSTIC_SEVERITY = {\n    [SEVERITY.Error]: 1,\n    [SEVERITY.Warning]: 2,\n    [SEVERITY.Information]: 3,\n    [SEVERITY.Hint]: 4,\n};\nconst invariant = (condition, message) => {\n    if (!condition) {\n        throw new Error(message);\n    }\n};\nexport function getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {\n    var _a, _b;\n    let ast = null;\n    let fragments = '';\n    if (externalFragments) {\n        fragments =\n            typeof externalFragments === 'string'\n                ? externalFragments\n                : externalFragments.reduce((acc, node) => acc + print(node) + '\\n\\n', '');\n    }\n    const enhancedQuery = fragments ? `${query}\\n\\n${fragments}` : query;\n    try {\n        ast = parse(enhancedQuery);\n    }\n    catch (error) {\n        if (error instanceof GraphQLError) {\n            const range = getRange((_b = (_a = error.locations) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : { line: 0, column: 0 }, enhancedQuery);\n            return [\n                {\n                    severity: DIAGNOSTIC_SEVERITY.Error,\n                    message: error.message,\n                    source: 'GraphQL: Syntax',\n                    range,\n                },\n            ];\n        }\n        throw error;\n    }\n    return validateQuery(ast, schema, customRules, isRelayCompatMode);\n}\nexport function validateQuery(ast, schema = null, customRules, isRelayCompatMode) {\n    if (!schema) {\n        return [];\n    }\n    const validationErrorAnnotations = validateWithCustomRules(schema, ast, customRules, isRelayCompatMode).flatMap(error => annotations(error, DIAGNOSTIC_SEVERITY.Error, 'Validation'));\n    const deprecationWarningAnnotations = validate(schema, ast, [\n        NoDeprecatedCustomRule,\n    ]).flatMap(error => annotations(error, DIAGNOSTIC_SEVERITY.Warning, 'Deprecation'));\n    return validationErrorAnnotations.concat(deprecationWarningAnnotations);\n}\nfunction annotations(error, severity, type) {\n    if (!error.nodes) {\n        return [];\n    }\n    const highlightedNodes = [];\n    for (const [i, node] of error.nodes.entries()) {\n        const highlightNode = node.kind !== 'Variable' && 'name' in node && node.name !== undefined\n            ? node.name\n            : 'variable' in node && node.variable !== undefined\n                ? node.variable\n                : node;\n        if (highlightNode) {\n            invariant(error.locations, 'GraphQL validation error requires locations.');\n            const loc = error.locations[i];\n            const highlightLoc = getLocation(highlightNode);\n            const end = loc.column + (highlightLoc.end - highlightLoc.start);\n            highlightedNodes.push({\n                source: `GraphQL: ${type}`,\n                message: error.message,\n                severity,\n                range: new Range(new Position(loc.line - 1, loc.column - 1), new Position(loc.line - 1, end)),\n            });\n        }\n    }\n    return highlightedNodes;\n}\nexport function getRange(location, queryText) {\n    const parser = onlineParser();\n    const state = parser.startState();\n    const lines = queryText.split('\\n');\n    invariant(lines.length >= location.line, 'Query text must have more lines than where the error happened');\n    let stream = null;\n    for (let i = 0; i < location.line; i++) {\n        stream = new CharacterStream(lines[i]);\n        while (!stream.eol()) {\n            const style = parser.token(stream, state);\n            if (style === 'invalidchar') {\n                break;\n            }\n        }\n    }\n    invariant(stream, 'Expected Parser stream to be available.');\n    const line = location.line - 1;\n    const start = stream.getStartOfToken();\n    const end = stream.getCurrentPosition();\n    return new Range(new Position(line, start), new Position(line, end));\n}\nfunction getLocation(node) {\n    const typeCastedNode = node;\n    const location = typeCastedNode.loc;\n    invariant(location, 'Expected ASTNode to have a location.');\n    return location;\n}\n//# sourceMappingURL=getDiagnostics.js.map","import CodeMirror from 'codemirror';\nimport { getDiagnostics } from 'graphql-language-service';\nconst SEVERITY = ['error', 'warning', 'information', 'hint'];\nconst TYPE = {\n    'GraphQL: Validation': 'validation',\n    'GraphQL: Deprecation': 'deprecation',\n    'GraphQL: Syntax': 'syntax',\n};\nCodeMirror.registerHelper('lint', 'graphql', (text, options) => {\n    const { schema, validationRules, externalFragments } = options;\n    const rawResults = getDiagnostics(text, schema, validationRules, undefined, externalFragments);\n    const results = rawResults.map(error => ({\n        message: error.message,\n        severity: error.severity ? SEVERITY[error.severity - 1] : SEVERITY[0],\n        type: error.source ? TYPE[error.source] : undefined,\n        from: CodeMirror.Pos(error.range.start.line, error.range.start.character),\n        to: CodeMirror.Pos(error.range.end.line, error.range.end.character),\n    }));\n    return results;\n});\n//# sourceMappingURL=lint.js.map"],"names":["Range","start","end","_this","_classCallCheck","this","containsPosition","position","line","character","_createClass","key","value","Position","__name","_this2","lessThanOrEqualTo","LoneSchemaDefinitionRule","context","_ref","_ref2","_oldSchema$astNode","oldSchema","getSchema","alreadyDefined","astNode","getQueryType","getMutationType","getSubscriptionType","schemaDefinitionsCount","SchemaDefinition","node","reportError","GraphQLError","nodes","UniqueOperationTypesRule","schema","definedOperationTypes","Object","create","existingOperationTypes","query","mutation","subscription","checkOperationTypes","SchemaExtension","_node$operationTypes","_step","operationTypesNodes","operationTypes","_iterator","_createForOfIteratorHelper","s","n","done","operationType","operation","alreadyDefinedOperationType","concat","err","e","f","UniqueTypeNamesRule","knownTypeNames","ScalarTypeDefinition","checkTypeName","ObjectTypeDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","InputObjectTypeDefinition","typeName","name","getType","UniqueEnumValueNamesRule","existingTypeMap","getTypeMap","knownValueNames","checkValueUniqueness","EnumTypeExtension","_node$values","valueNodes","values","valueNames","valueDef","valueName","existingType","isEnumType","getValue","UniqueFieldDefinitionNamesRule","knownFieldNames","checkFieldUniqueness","InputObjectTypeExtension","InterfaceTypeExtension","ObjectTypeExtension","_node$fields","fieldNodes","fields","fieldNames","fieldDef","fieldName","hasField","type","isObjectType","isInterfaceType","isInputObjectType","getFields","UniqueDirectiveNamesRule","knownDirectiveNames","DirectiveDefinition","directiveName","getDirective","isExecutableDefinitionNode","kind","Kind","OPERATION_DEFINITION","FRAGMENT_DEFINITION","isTypeSystemDefinitionNode","SCHEMA_DEFINITION","isTypeDefinitionNode","DIRECTIVE_DEFINITION","SCALAR_TYPE_DEFINITION","OBJECT_TYPE_DEFINITION","INTERFACE_TYPE_DEFINITION","UNION_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","isTypeSystemExtensionNode","SCHEMA_EXTENSION","isTypeExtensionNode","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","KnownTypeNamesRule","existingTypesMap","definedTypes","getDocument","definitions","def","typeNames","_toConsumableArray","keys","NamedType","_1","parent","_2","ancestors","_ancestors$","definitionNode","isSDL","standardTypeNames","includes","suggestedTypes","suggestionList","didYouMean","specifiedScalarTypes","introspectionTypes","map","KnownDirectivesRule","locationsMap","definedDirectives","getDirectives","specifiedDirectives","directive","locations","_step2","astDefinitions","_iterator2","Directive","_key","_parent","_path","candidateLocation","appliedTo","length","invariant","OperationTypeNode","QUERY","DirectiveLocation","MUTATION","SUBSCRIPTION","getDirectiveLocationForOperation","FIELD","FRAGMENT_SPREAD","INLINE_FRAGMENT","VARIABLE_DEFINITION","SCHEMA","SCALAR","OBJECT","FIELD_DEFINITION","INTERFACE","UNION","ENUM","ENUM_VALUE_DEFINITION","ENUM_VALUE","INPUT_OBJECT","INPUT_VALUE_DEFINITION","parentNode","INPUT_FIELD_DEFINITION","ARGUMENT_DEFINITION","inspect","getDirectiveLocationForASTPath","UniqueDirectivesPerLocationRule","uniqueDirectiveMap","isRepeatable","repeatable","schemaDirectives","typeDirectivesMap","enter","directives","seenDirectives","undefined","_step3","_iterator3","PossibleTypeExtensionsRule","ScalarTypeExtension","checkExtension","UnionTypeExtension","expectedKind","defNode","defKindToExtKind","isScalarType","isUnionType","typeToExtKind","kindStr","extensionKindToTypeName","allTypeNames","_objectSpread","_defKindToExtKind","_defineProperty","groupBy","list","keyFn","result","Map","item","group","get","set","push","UniqueArgumentNamesRule","Field","checkArgUniqueness","_parentNode$arguments","seenArgs","arguments","arg","_step$value","_slicedToArray","argName","argNodes","UniqueInputFieldNamesRule","knownNameStack","knownNames","ObjectValue","leave","prevKnownNames","pop","ObjectField","ExecutableDefinitionsRule","Document","definition","defName","KnownArgumentNamesOnDirectivesRule","directiveArgs","args","_def$arguments","argsNodes","directiveNode","knownArgs","argNode","suggestions","KnownFragmentNamesRule","FragmentSpread","fragmentName","getFragment","NoUnusedFragmentsRule","operationDefs","fragmentDefs","OperationDefinition","FragmentDefinition","fragmentNameUsed","_i","_operationDefs","getRecursivelyReferencedFragments","_i2","_fragmentDefs","fragmentDef","fragName","sortValueNode","valueNode","fieldNode","sort","fieldA","fieldB","naturalCompare","LIST","INT","FLOAT","STRING","BOOLEAN","NULL","VARIABLE","reasonMessage","reason","Array","isArray","responseName","subReason","join","collectConflictsBetweenFieldsAndFragment","conflicts","cachedFieldsAndFragmentNames","comparedFragmentPairs","areMutuallyExclusive","fieldMap","fragment","_getReferencedFieldsA","getReferencedFieldsAndFragmentNames","_getReferencedFieldsA2","fieldMap2","referencedFragmentNames","collectConflictsBetween","referencedFragmentName","has","add","collectConflictsBetweenFragments","fragmentName1","fragmentName2","fragment1","fragment2","_getReferencedFieldsA3","_getReferencedFieldsA4","fieldMap1","referencedFragmentNames1","_getReferencedFieldsA5","_getReferencedFieldsA6","referencedFragmentNames2","_step4","_iterator4","parentFieldsAreMutuallyExclusive","_Object$entries2","entries","_Object$entries2$_i","fields1","fields2","_step9","_iterator9","_step10","field1","_iterator10","conflict","findConflict","field2","_field","parentType1","node1","def1","_field2","parentType2","node2","def2","name1","name2","args1","args2","values2","_ref3","every","arg1","value1","value2","stringifyValue","sameArguments","type1","type2","doTypesConflict","selectionSet1","selectionSet","selectionSet2","_getFieldsAndFragment3","getFieldsAndFragmentNames","_getFieldsAndFragment4","fragmentNames1","_getFieldsAndFragment5","_getFieldsAndFragment6","fragmentNames2","_step5","_iterator5","_step6","_iterator6","_step7","_iterator7","_step8","_iterator8","findConflictsBetweenSubSelectionSets","getNamedType","_ref4","_ref6","flat","_ref8","subfieldConflicts","print","isListType","ofType","isNonNullType","isLeafType","parentType","cached","nodeAndDefs","fragmentNames","_collectFieldsAndFragmentNames","fragmentType","typeFromAST","typeCondition","_step11","_iterator11","selections","selection","alias","inlineFragmentType","PairSet","_data","a","b","_this$_data$get","_ref10","_ref11","key1","key2","_ref12","_ref13","ProvidedRequiredArgumentsOnDirectivesRule","_schema$getDirectives","requiredArgsMap","keyMap","filter","isRequiredArgument","isRequiredArgumentNode","requiredArgs","_directiveNode$argume","argNodeMap","Set","_Object$entries","_Object$entries$_i","argDef","argType","isType","NON_NULL_TYPE","defaultValue","getDirectiveValues","directiveDef","variableValues","_node$directives","find","_node$arguments","coercedValues","argumentNodes","argumentNode","isNull","variableName","hasOwnProperty","coercedValue","valueFromAST","getArgumentValues","obj","prop","prototype","call","collectFieldsImpl","fragments","runtimeType","visitedFragmentNames","shouldIncludeNode","fieldList","doesFragmentConditionMatch","skip","GraphQLSkipDirective","if","include","GraphQLIncludeDirective","typeConditionNode","conditionalType","isAbstractType","isSubType","isValidValueNode","locationType","getInputType","parseLiteral","typeStr","error","message","originalError","allowedVariableUsage","varType","varDefaultValue","locationDefaultValue","nullableLocationType","isTypeSubTypeOf","specifiedRules","freeze","knownOperationNames","operationName","operationCount","subscriptionType","document","collectFields","size","extraFieldSelections","slice","startsWith","InlineFragment","isCompositeType","VariableDefinition","isInputType","variable","getParentType","getFieldDef","suggestion","usageCount","getPossibleTypes","possibleType","getInterfaces","_usageCount$possibleI","possibleInterface","typeA","typeB","usageCountDiff","x","getSuggestedTypeNames","possibleFieldNames","getSuggestedFieldNames","knownFragmentNames","fragType","doTypesOverlap","parentTypeStr","fragTypeStr","frag","getFragmentType","visitedFrags","spreadPath","spreadPathIndexByName","detectCycleRecursive","spreadNodes","getFragmentSpreads","spreadNode","spreadName","cycleIndex","spreadFragment","cyclePath","viaPath","operationNode","_operationNode$variab","seenVariableDefinitions","variableDefinitions","variableNodes","variableNameDefined","usages","getRecursiveVariableUsages","varName","variableDefs","variableNameUsed","_variableDefs","variableDef","Argument","getArgument","knownArgsNames","ListValue","getNullableType","getParentInputType","fieldNodeMap","field","_Object$values","isRequiredInputField","NullValue","EnumValue","IntValue","FloatValue","StringValue","BooleanValue","_fieldNode$arguments","providedArgs","argTypeStr","varDefMap","varDef","varTypeStr","SelectionSet","_getFieldsAndFragment","_getFieldsAndFragment2","i","j","collectConflictsWithin","findConflictsWithinSelectionSet","_step$value$","reasonMsg","checkArgUniquenessPerField","typeNode","_typeNode$fields","_fieldDef$arguments","parentName","_step2$value","ASTValidationContext","_Symbol$toStringTag","ast","onError","_ast","_fragments","_fragmentSpreads","_recursivelyReferencedFragments","_onError","spreads","setsToVisit","collectedNames","nodesToVisit","Symbol","toStringTag","ValidationContext","_ASTValidationContext2","_Symbol$toStringTag3","_inherits","_super2","_createSuper","typeInfo","_schema","_typeInfo","_variableUsages","_recursiveVariableUsages","newUsages","TypeInfo","visit","visitWithTypeInfo","Variable","getDefaultValue","getVariableUsages","getEnumValue","validate","documentAST","_options$maxErrors","rules","options","maxErrors","devAssert","assertValidSchema","abortObj","errors","visitor","visitInParallel","rule","NoDeprecatedCustomRule","deprecationReason","inputObjectDef","inputFieldDef","enumValueDef","enumTypeDef","specifiedSDLRules","validateWithCustomRules","customRules","isRelayCompatMode","isSchemaDocument","apply","DIRECTIVE","SEVERITY$1","DIAGNOSTIC_SEVERITY","_DIAGNOSTIC_SEVERITY","condition","Error","getDiagnostics","_a","_b","externalFragments","reduce","acc","enhancedQuery","parse","range","getRange","column","severity","source","validateQuery","validationErrorAnnotations","flatMap","annotations","deprecationWarningAnnotations","Warning","highlightedNodes","highlightNode","loc","highlightLoc","getLocation","location","queryText","parser","onlineParser","state","startState","lines","split","stream","CharacterStream","eol","token","getStartOfToken","getCurrentPosition","SEVERITY","TYPE","CodeMirror","registerHelper","text","validationRules","from","Pos","to"],"sourceRoot":""}